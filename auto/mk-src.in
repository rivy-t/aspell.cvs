#
# mk-src.in -- Input file for the Perl program to automatically 
#	       generate interface code.
#
# This file is part of The New Aspell
# Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL
# license version 2.0 or 2.1.  You should have received a copy of the
# LGPL license along with this library if you did not you can find it
# at http://www.gnu.org/.

=head1 mk-src.in

The format of mk-src.in is as follows:

  The following charaters are literals: { } / '\ ' \n = >

  <items>
  <items> := (<item>\n)+
  <items> := <category>:\ <name> {\n<details>\n} | <<tab>><details>
  <details> := <options>\n /\n <items>
  <options> := (<option>\n)*
  <option> := <key> [=> <value>]

  <<tab>> means everything should be indented by one tab

See MkSrc::Info for a description of the categorys and options

=cut


#group: type id
#{
#/
#union: type id
#	treat as object
#	/
#	unsigned int: num
#		default => 0
#	array 4 char: str
#	cxx constructor:
#		/
#		string: str
#}
methods: destructible
	/
	destructor
	
#	int: ref count
#		default => 0
#
#	method: ref count
#		desc => returns a pointer to an int which may be used
#			for refrence counting.	It will default to 0.
#			This integer is not used by the actual library
#			but may be used my some of the front ends.
#		c only
#		c impl => return &ths->ref_count;
#		/
#		int pointer

methods: copyable
	/
	destructible methods

#	type id: type id
#
#	method: type id
#		desc => To objects of the same pointer type may be
#			assigned to each other only if there type ids 
#			are the same.
#		cxx impl => return type_id_.num
#		/
#		unsigned int
#
#	int: copyable
#		default => 2
#
#	method: copyable
#		desc => Returns 0 if this object can not be copied,
#			1 if it may be copies, 2 if it should be
#			copyied.  Used by some of the front end to
#			detrime if a deep or shallow copy should be 
#			made.
#		cxx impl => return copyable_
#		/
#		int

	method: clone
		const
		/
		$
	
	method: assign
		/
		void
		const $: other

methods: can have error
	/
	cxx member: err
		what => CopyPtr<Error> err_
		headers => copy ptr, error

	method: error number
		const
		c only
		c impl => return ths->err_ == 0 ? 0 : 1;
		desc => deprecated
		/
		unsigned int

	method: error message
		const
		c only
		c impl => return ths->err_ ? ths->err_->mesg : "";
		/
		string

	method: error
		const
		c only
		c impl => return ths->err_;
		/
		const error

methods: mutable container
	c impl headers => posib err
	/
	public: mutable container
	method: add
		/
		bool
		string: to_add

	method: remove
		/
		bool
		string: to_rem

	method: clear
		/
		void

	method: to mutable container
		c only
		c impl => return ths;
		/
		mutable container

group: mutable container
{
no native
/
class: mutable container
	/
	mutable container methods
}
methods: list
	
	strip => 1
	/
	method: empty
		const
		/
		bool

	method: size
		const
		/
		unsigned int

	method: elements
		const
		/
		$ enumeration

methods: enumeration

	strip => 1
	
	/
	method: at end
		const
		/
		bool

	method: next
		/
		const $

group: key info
{
/
enum: key info type
	prefix => key info
	/
	string
	int
	bool
	list

struct: key info
	desc => The Key Info object is used for holding information
		about a valid key
	/
	string: name
		desc => the name of the key
	key info type: type
		desc => the key type
	string: def
		desc => the default value of the key
	string: desc
		desc => a brief description of the key or null if internal value
	int: flags
	int: other data
}	
group: config
{
no native
/
class: key info enumeration
	/
	enumeration methods
	copyable methods

class: config
	c impl headers => error
	/
	constructor

	copyable methods

	can have error methods

	method: set extra
		desc => sets extra keys which this config class should accept
			begin and end are expected to point to the begging 
			and end of an array of Aspell Key Info
		/
		void
		const key info: begin
		const key info: end

	method: keyinfo
		posib err
		desc => returns the KeyInfo object for the
			corresponding key or returns null and sets
			error_num to PERROR_UNKNOWN_KEY if the key is
			not valid. The pointer returned is valid for
			the lifetime of the object.
		/
		const key info
		string: key

	method: possible elements
		desc => returns a newly allocated enumeration of all the 
			possible objects this config class uses
		/
		key info enumeration
		int: include extra

	method: get default
		posib err
		desc => returns the default value for given key which
			way involve substating variables, thus it is
			not the same as keyinfo(key)->def returns null
			and sets error_num to PERROR_UNKNOWN_KEY if
			the key is not valid. Uses the temporary
			string.
		/
		string obj
		string: key

	method: elements
		desc => returns a newly alloacted enumeration of all the
			key/value pairs. This DOES not include ones
			which are set to their default values
		/
		string pair enumeration

	method: replace
		posib err
		desc => inserts an item, if the item already exists it
			will be replaced. returns true if it succesed
			or false on error. If the key in not valid it
			sets error_num to PERROR_UNKNOWN_KEY, if the
			value is not valid it will sets error_num to
			PERROR_BAD_VALUE, if the value can not be
			changed it sets error_num to
			PERROR_CANT_CHANGE_VALUE, and if the value is
			a list and you are trying to set it directory
			it sets error_num to PERROR_LIST_SET
		/
		void
		string: key
		string: value

	method: remove
		posib err
		desc => remove a key and returns true if it exists 
			otherise return false. This effictly sets the
			key to its default value. Calling replace with
			a value of "<default>" will also call
			remove. If the key does not exists sets
			error_num to 0 or PERROR_NOT, if the key in
			not valid sets error_num to
			PERROR_UNKNOWN_KEY, if the value can not be
			changed sets error_num to
			PERROR_CANT_CHANGE_VALUE
		/
		void
		string: key

	method: have
		const
		/
		bool
		string: key

	method: retrieve
		posib err
		desc => returns null on error
		/
		string obj
		string: key

	method: retrieve list
		posib err
		/
		void
		string: key
		mutable container: lst

	method: retrieve bool
		posib err
		desc => return -1 on error, 0 if false, 1 if true
		/
		bool
		string: key

	method: retrieve int
		posib err
		desc => return -1 on error
		/
		unsigned int
		string: key

#	method: read_in_settings
#		posib err
#		/
#		bool

#	method: settings_read_in
#		/
#		bool
}
group: error
{
/
struct: error
	/
	string: mesg
	const error info: err
	method: is a
		const
		/
		bool
		const error info: e

struct: error info
	/
	const error info: isa
	string: mesg
	unsigned int: num parms
	array 3 string: parms
}
group: can have error
{
no native
/
class: can have error
	c impl headers => error
	/
	can have error methods
		prefix => 
	destructible methods
}
group: errors
{
/
errors:
	/
	other
	operation not supported
		mesg => Operation Not Supported: %what
		parms => what
		/
		cant copy
		unimplemented method
			mesg => The method "%what" is unimplemented in "%where".
			parms => where
	file
		mesg => %file:
		parms => file
		/
		cant open file
			mesg => The file "%file" can not be opened
			/
			cant read file
				mesg => The file "%file" can not be opened for reading.
			cant write file
				mesg => The file "%file" can not be opened for writing.
		invalid name
			mesg => The file name "%file" is invalid.
		bad file format
			mesg => The file "%file" is not in the proper format.
	dir
		parms => dir
		/
		cant read dir
			mesg => The directory "%dir" can not be opened for reading.
			
	config
		parms => key
		/
		unknown key
			mesg => The key "%key" is unknown.
		cant change value
			mesg => The value for option "%key" can not be changed.
		bad key
			mesg => The key "%key" is not %accepted and is thus invalid.
			parms => accepted
		bad value
			mesg => The value "%value" is not %accepted and is thus invalid for the key "%key".
			parms => value, accepted
		empty value
			mesg => You must specify a value for the key "%key".
		duplicate
		key not string
			mesg => The key "%key" is not a string.
		key not int
			mesg => The key "%key" is not an integer.
		key not bool
			mesg => The key "%key" is not a boolean.
		key not list
			mesg => The key "%key" is not a list.
		no_value_reset
			mesg => The key "%key" does not take any parameters when prefixed by a "reset-".
		no_value_enable
			mesg => The key "%key" does not take any parameters when prefixed by a "enable-".
		no_value_disable
			mesg => The key "%key" does not take any parameters when prefixed by a "dont-" or "disable-".
		no_value_clear
			mesg => The key "%key" does not take any parameters when prefixed by a "clear-".

	language related
		parms => lang
		/
		unknown language
			mesg => The language "%lang" is not known.
		unknown soundslike
			mesg => The soundslike "%sl" is not known.
			parms => sl
		language not supported
			mesg => The language "%lang" is not supported.
		no wordlist for lang
			mesg => No word lists can be found for the language "%lang".
		mismatched language
			mesg => Expected language "%lang" but got "%prev".
			parms => prev
	affix
		/
		corrupt affix
			mesg => Affix '%aff' is corrupt.
			parms => aff
		invalid cond
			mesg => The condition "%cond" is invalid.
			parms => cond
		invalid cond strip
			mesg => The condition "%cond" does not guarantee that "%strip" can always be stripped.
			parms => cond, strip
		incorrect encoding
			mesg => The file "%file" is not in the proper format. Expected the file to be in "%exp" not "%got".
			parms => file, exp, got
	encoding
		parms => encod
		/
		unknown encoding
			mesg => The encoding "%encod" is not known.
		not simple encoding
			mesg => The encoding "%encod" is not a simple encoding and therefor can not be used in this context.
		encoding not supported
			mesg => The encoding "%encod" is not supported.
		conversion not supported
			mesg => The conversion from "%encod" to "%encod2" is not supported.
			parms => encod2
	pipe
		/
		cant create pipe
		process died
	bad input
		/
		invalid string
			mesg => The string "%str" is invalid.
			parms => str
		invalid word
			mesg => The word "%word" is invalid.
			parms => word
		expecting_not
			mesg => Expecting "%exp" but got "%got".
			parms => exp, got
		invalid affix
			mesg => The affix flag '%aff' is invalid for word "%word".
			parms => aff, word
		inapplicable affix
			mesg => The affix flag '%aff' can not be applied to word "%word".
			parms => aff, word
		unknown unichar
			mesg => 
		word list flags
			/
			invalid flag
			conflicting flags
	version control
		/
		bad version string
			mesg => not a version number
	filter
		/
		cant dlopen file
			mesg => dlopen returned "%return". 
			parms => return
		empty filter
			mesg => The file "%filter" does not contain any filters.
			parms => filter
		no such filter
			mesg => The filter "%filter" does not exist.
			parms => filter
		confusing version
			mesg => Confused by version control.
		bad version
			mesg => Aspell version does not match filter's requirement.
		identical option
			mesg => Filter option already exists.
		options only
			mesg => Use option modifiers only within named option.
		invalid option modifier
			mesg => Option modifier unknown.
		cant describe filter
			mesg => Error setting filter description.
	filter mode file
		/
		mode option name
			mesg => Empty option specifier.
		no filter to option 
			mesg => Option "%option" possibly specified prior to filter.
			parms => option
		bad mode key 
			mesg => Unknown mode description key "%key".
			parms => key
		expect mode key
			mesg => Expecting "%modekey" key.
			parms => modekey
		mode version requirement
			mesg => Version specifier missing key: "aspell".
		confusing mode version
			mesg => Confused by version control.
		bad mode version
			mesg => Aspell version does not match mode's requirement.
		missing magic expression
			mesg => Missing magic mode expression.
		empty file ext
			mesg => Empty extension at char %char.
			parms => char
	filter mode expand
		mesg => "%mode" error
		parms => mode
		/
		unknown mode
			mesg => Unknown mode: "%mode".
		mode extend expand
			mesg => "%mode" error while extend Aspell modes. (out of memory?)
	filter mode magic
		mesg = "%mode": bad magic "%magic"
		parms => mode, magic
		/
		file magic pos
			mesg => "%mode": no start for magic search given for magic "%magic".
		file magic range
			mesg => "%mode": no range for magic search given for magic "%magic".
		missing magic 
			mesg => "%mode": no magic expression available for magic "%magic".
		bad magic
			mesg => "%mode": Magic "%magic": bad regular expression after location specifier; regexp reports: "%regerr".
			parms => regerr

	expression
		/
		invalid expression
			mesg => "%expression" is not a valid regular expression.
			parms => expression
	convert filter
		/
		invalid table entry
			mesg => Each row in the table must have at least %cols columns.
			parms => cols
}
group: check info
{
/
struct: check info
	/
	const check info pointer: next
	string: str
	unsigned int: str len
	int: guess
}

group: speller
{
no native
/
class: speller
	/
	posib err constructor
		/
		config: config

	destructible methods

	can have error methods

	method: config
		/
		config

	method: check

		posib err
		desc => returns	 0 if it is not in the dictionary, 
			1 if it is, or -1 on error.
		/
		bool
		encoded string: word

	method: check info
	
		no c impl

		/

		const check info
	
	method: add to personal
		
		posib err
		/
		void
		encoded string: word

	method: add lower to personal
		
		posib err
		/
		void
		encoded string: word

	method: add to session

		posib err
		/
		void
		encoded string: word

	method: add lower to session
		
		posib err
		/
		void
		encoded string: word

	method: personal word list

		posib err
		/
		const word list
		
	method: session word list

		posib err
		/
		const word list

	method: main word list

		posib err
		/
		const word list

	method: save all word lists
	
		posib err
		/
		void

	method: clear session

		posib err
		/
		void

	method: suggest

		posib err
		desc => Return null on error. 
			the word list returned by suggest is only valid until the next
			call to suggest
		/
		const word list
		encoded string: word
		
	method: store replacement

		posib err
		/
		bool
		encoded string: mis
		encoded string: cor

}

group: language types
{
/
enum: case pattern
	/
	other
	first upper
	all lower
	all upper
struct: word
	/
	string: str
	int: len
		default => -1
callback: get word callback
	/
	bool
	void pointer: data
	word: word
callback: put word callback
	/
	bool
	void pointer: data
	const word: word
struct: munch list parms
	/
	constructor
		c impl => return new MunchListParms;
	destructible methods
	bool: multi
		default => false
	bool: simplify
		default => true
}
group: language
{
no native
/
class: language
	indirect
	base => const LangBase
	/
	posib err constructor
		no c impl
		/
		config: config

	destructible methods

	can have error methods

	method: case pattern
		/
		case pattern
		encoded string: str
	method: fix case
		/
		encoded string
		case pattern: cs
		encoded string: str
	method: to soundslike
		/
		encoded string
		encoded string: str
	method: munch
		no c impl
		/
		int
		encoded string: str
		put word callback: out cb
		void pointer: out cb data
	method: expand
		no c impl
		/
		int
		encoded string: str
		put word callback: out cb
		void pointer: out cb data
		int: limit
	method: munch list
		no c impl
		/
		int
		get word callback: in cb
		void pointer: in cb data
		put word callback: out cb
		void pointer: out cb data
		munch list parms: parms
}

group: word list
{
/
class: word list
	c impl headers => string enumeration
	/
	cxx member: from internal
		what => class FullConvert * from_internal_
		default => 0

	method: empty
		const
		/
		bool

	method: size
		const
		/
		unsigned int
	
	method: elements
		const
		c impl =>
			StringEnumeration * els = ths->elements();
			els->from_internal_ = ths->from_internal_;
			return els;
		/
		string enumeration
}
group: string enumeration
{
no native
/
class: string enumeration
	c impl headers => convert
	/
	copyable methods
	method: at end
		const
		/
		bool

	method: next
		c impl =>
			const char * s = ths->next();
			if (s == 0 || ths->from_internal_ == 0) \{
			  return s;
			\} else \{
			  ths->temp_str.clear();
			  ths->from_internal_->convert(s,-1,ths->temp_str);
			  ths->from_internal_->append_null(ths->temp_str);
			  return ths->temp_str.data();
			\}
		/
		const string

}

group: info types
{
/
struct: module info
	/
	string: name
	double: order num
	string: lib dir
	string list: dict dirs
	string list: dict exts

struct: dict info
	/
	string: name
		desc => name to identify the dictionary by
	string: code
	string: jargon
	int: size
	string: size str
	module info: module
}

group: info
{
no native
no impl
/
class: module info list
	/
	constructor: get aspell module info list
		/
		config: config

	list methods

class: dict info list
	/
	constructor: get aspell dict info list
		/
		config: config

	list methods

class: module info enumeration
	/
	enumeration methods
	copyable methods

class: dict info enumeration
	/
	enumeration methods
	copyable methods
}

group: string list
{
no native
/
class: string list
	/
	constructor

	list methods

	mutable container methods

	copyable methods
}

group: string map
{
no native
/
class: string map
	/
	constructor

	mutable container methods

	copyable methods

	list methods: string pair
	
	method: insert
		desc => Insert a new element. 
			Will NOT overright an existing entry.
			Returns false if the element already exists.
		/
		bool
		string: key
		string: value

	method: replace
		desc => Insert a new element. 
			Will overright an existing entry.
			Always returns true.
		/
		bool
		string: key
		string: value

	method: lookup
		const
		desc => Looks up an element.
			Returns null if the element did not exist.
			Returns an empty string if the element exists but has a null value.
			Otherwises returns the value
		/
		string
		string: key
}

group: string pair
{
/
struct: string pair
	treat as object
	/
	string: first
		default => ""
	string: second
		default => ""
	cxx extra:
		what => StringPair(const char * f, const char * s) : first(f), second(s) {}
}
group: string pair enumeration
{
/
class: string pair enumeration
	/
	enumeration methods
	copyable methods
}
group: cache
{
/
func: reset cache
	desc => Reset the global cache(s) so that cache queries will create a new
		object.	 If exiting objects are still in use they are not deleted.
		If which is NULL than ALL caches will be reset.	 Current caches are
		"encode", "decode", "dictionary", "language", and "keyboard".
	/
	bool
	string: which
}

group: checker types
{
/
struct: checker pos
	treat as object
	/
	void pointer: which
	unsigned int: offset

struct: checker token
	/
	checker pos: begin
	checker pos: end
	bool: correct

callback: more data callback
	/
	void
	void pointer: data
	void pointer: which

callback: string freed callback
	/
	void
	void pointer: data
	void pointer: which
}

group: checker
{
no native
/
class: checker
	/
	posib err constructor
		/
		speller: speller

	destructible methods
	
	can have error methods

	method: reset
		/
		void

	method: process
		/
		void
		string: str
		unsigned int: size
		unsigned int: ignore
		void pointer: which
	
	method: add separator
		/
		void

	method: replace
		/
		void
		string: str
		unsigned int: size

	method: next
		/
		const checker token
	
	method: next misspelling
		/
		const checker token
	
	method: cur
		const
		/
		const checker token

	method: set more data callback
		/
		void
		more data callback: callback
		void pointer: callback data

	method: set string freed callback
		/
		void
		string freed callback: callback
		void pointer: callback data

	method: set span strings
		/
		void
		bool: value
}

group: document checker
{
no native
no impl
/
struct: token
	/
	unsigned int: offset
	unsigned int: len

class: document checker
	c impl headers => error
	/
	posib err constructor: 
		desc => Creates a new document checker.
			The speller class is expect to last until this
			class is destroyed.
			If config is given it will be used to overwide
			any relevent options set by this speller class.
			The config class is not once this function is done.
			If filter is given then it will take ownership of 
			the filter class and use it to do the filtering.
			You are expected to free the checker when done.
		/
		speller: speller

	destructible methods
	
	can have error methods

	method: reset

		desc => reset the internal state of the filter.
			should be called whenever a new document is being filtered
		/
		void

	method: process
	
		desc => process a string
			The string passed in should only be split on white space
			characters.  Furthermore, between calles to reset, each string
			should be passed in exactly once and in the order they appeared
			in the document.  Passing in stings out of order, skipping
			strings or passing them in more than once may lead to undefined
			results.
		/
		void
		string: str
		int: size

	method: next misspelling
	
		desc => returns the next misspelled word in the processed string
			if there are no more misspelled word than token.word
			will be null and token.size will be 0
		/
		token object
}
group: convert
{
no native
no impl
/
enum: normalize
	prefix => norm
	/
	none
	from
	to
	both

class: convert
	/
	posib err constructor
		/
		config: c
		string: from
		string: to
		normalize: n
		bool: filter

	destructible methods

	method: needed
		desc => returns true if a conversion if needed
		/
		bool

	method:
		desc => converts a null terminated string.
			If no conversion is needed returns the orignal string,
			otherwise returns the converted string.	 The string
			returned is only valid until the next call to convert.
		/
		string
		string: str
}
